using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace Roblox_Exploit_API_Source
{
	internal class DLLInjection
	{
		public enum DllInjectionResult
		{
			DllNotFound,
			GameProcessNotFound,
			InjectionFailed,
			Success
		}
		public sealed class DllInjector
		{
			public static DLLInjection.DllInjector GetInstance
			{
				get
				{
					bool flag = DLLInjection.DllInjector._instance == null;
					bool flag2 = flag;
					bool flag3 = flag2;
					if (flag3)
					{
						DLLInjection.DllInjector._instance = new DLLInjection.DllInjector();
					}
					return DLLInjection.DllInjector._instance;
				}
			}
			private DllInjector()
			{
			}
			private bool bInject(uint pToBeInjected, string sDllPath)
			{
				IntPtr intPtr = DLLInjection.DllInjector.OpenProcess(1082U, 1, pToBeInjected);
				bool flag = intPtr == DLLInjection.DllInjector.INTPTR_ZERO;
				bool flag2 = flag;
				bool flag3 = flag2;
				bool result;
				if (flag3)
				{
					result = false;
				}
				else
				{
					IntPtr procAddress = DLLInjection.DllInjector.GetProcAddress(DLLInjection.DllInjector.GetModuleHandle("kernel32.dll"), "LoadLibraryA");
					bool flag4 = procAddress == DLLInjection.DllInjector.INTPTR_ZERO;
					bool flag5 = flag4;
					bool flag6 = flag5;
					if (flag6)
					{
						result = false;
					}
					else
					{
						IntPtr intPtr2 = DLLInjection.DllInjector.VirtualAllocEx(intPtr, (IntPtr)0, (IntPtr)sDllPath.Length, 12288U, 64U);
						bool flag7 = intPtr2 == DLLInjection.DllInjector.INTPTR_ZERO;
						bool flag8 = flag7;
						bool flag9 = flag8;
						if (flag9)
						{
							result = false;
						}
						else
						{
							byte[] bytes = Encoding.ASCII.GetBytes(sDllPath);
							bool flag10 = DLLInjection.DllInjector.WriteProcessMemory(intPtr, intPtr2, bytes, (uint)bytes.Length, 0) == 0;
							bool flag11 = flag10;
							bool flag12 = flag11;
							if (flag12)
							{
								result = false;
							}
							else
							{
								bool flag13 = DLLInjection.DllInjector.CreateRemoteThread(intPtr, (IntPtr)0, DLLInjection.DllInjector.INTPTR_ZERO, procAddress, intPtr2, 0U, (IntPtr)0) == DLLInjection.DllInjector.INTPTR_ZERO;
								bool flag14 = flag13;
								bool flag15 = flag14;
								if (flag15)
								{
									result = false;
								}
								else
								{
									DLLInjection.DllInjector.CloseHandle(intPtr);
									result = true;
								}
							}
						}
					}
				}
				return result;
			}
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern int CloseHandle(IntPtr hObject);
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttribute, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr GetModuleHandle(string lpModuleName);
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
			public DLLInjection.DllInjectionResult Inject(string sProcName, string sDllPath)
			{
				bool flag = !File.Exists(sDllPath);
				bool flag2 = flag;
				bool flag3 = flag2;
				DLLInjection.DllInjectionResult result;
				if (flag3)
				{
					result = DLLInjection.DllInjectionResult.DllNotFound;
				}
				else
				{
					uint num = 0U;
					Process[] processes = Process.GetProcesses();
					for (int i = 0; i < processes.Length; i++)
					{
						bool flag4 = !(processes[i].ProcessName != sProcName);
						bool flag5 = flag4;
						bool flag6 = flag5;
						if (flag6)
						{
							num = (uint)processes[i].Id;
							break;
						}
					}
					bool flag7 = num == 0U;
					bool flag8 = flag7;
					bool flag9 = flag8;
					if (flag9)
					{
						result = DLLInjection.DllInjectionResult.GameProcessNotFound;
					}
					else
					{
						bool flag10 = !this.bInject(num, sDllPath);
						bool flag11 = flag10;
						bool flag12 = flag11;
						if (flag12)
						{
							result = DLLInjection.DllInjectionResult.InjectionFailed;
						}
						else
						{
							result = DLLInjection.DllInjectionResult.Success;
						}
					}
				}
				return result;
			}

			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);
			[DllImport("kernel32.dll", SetLastError = true)]
			private static extern int WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, uint size, int lpNumberOfBytesWritten);
			private static readonly IntPtr INTPTR_ZERO = (IntPtr)0;
			private static DLLInjection.DllInjector _instance;
		}
	}
}
