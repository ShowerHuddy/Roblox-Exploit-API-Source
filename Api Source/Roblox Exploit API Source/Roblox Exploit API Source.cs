using System;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace Roblox_Exploit_API_Source
{
	public class REAS
	{
		public bool IsAttached()
		{
			return REAS.namedPipeExist("EXPLOIT DLL PIPE NAME");
		}

		private void DownloadDLL()
		{
			using (WebClient webClient = new WebClient())
			{
				bool flag = File.Exists("EXPLOIT DLL NAME.dll");
				bool flag2 = flag;
				if (flag2)
				{
					string address = "DOWNLOAD LINK FOR AUTO UPDATING";
					webClient.DownloadFile(address, "EXPLOIT DLL NAME.dll");
				}
				else
				{
					bool flag3 = !File.Exists("EXPLOIT DLL NAME.dll");
					bool flag4 = flag3;
					if (flag4)
					{
						string address2 = "https://github.com/ausu-u/FurkDLL/raw/main/FurkByteCode.dll";
						webClient.DownloadFile(address2, "EXPLOIT DLL NAME.dll");
					}
					else
					{
						MessageBox.Show("Dll Patched, ", "Error: Patched", MessageBoxButtons.OK, MessageBoxIcon.Hand);
					}
				}
			}
		}

		public void ExecuteScript(string Script)
		{
			bool flag = REAS.namedPipeExist("EXPLOIT DLL PIPE NAME");
			bool flag2 = flag;
			bool flag3 = flag2;
			if (flag3)
			{
				using (NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", "EXPLOIT DLL PIPE NAME", PipeDirection.Out))
				{
					namedPipeClientStream.Connect();
					using (StreamWriter streamWriter = new StreamWriter(namedPipeClientStream, Encoding.Default, 999999))
					{
						streamWriter.Write(Script);
						streamWriter.Dispose();
					}
					namedPipeClientStream.Dispose();
				}
			}
			else
			{
				bool flag4 = File.Exists("EXPLOIT DLL NAME.dll");
				bool flag5 = flag4;
				bool flag6 = flag5;
				if (flag6)
				{
					MessageBox.Show("Please attach!", "NamedPipeDoesntExist", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				}
				else
				{
					MessageBox.Show("Please turn off your antivirus!", "DLLDoesntExist", MessageBoxButtons.OK, MessageBoxIcon.Hand);
				}
			}
		}

		private void InjectDLL()
		{
			DLLInjection.DllInjectionResult dllInjectionResult = DLLInjection.DllInjector.GetInstance.Inject("RobloxPlayerBeta", Application.StartupPath + "\\EXPLOIT DLL NAME.dll");
			bool flag = dllInjectionResult == DLLInjection.DllInjectionResult.Success;
			bool flag2 = !flag;
			bool flag3 = flag2;
			if (flag3)
			{
				switch (dllInjectionResult)
				{
					case DLLInjection.DllInjectionResult.DllNotFound:
						MessageBox.Show("Couldn't find the dll!", "Error: Dll Not Found", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						break;
					case DLLInjection.DllInjectionResult.GameProcessNotFound:
						MessageBox.Show("No ROBLOX process found!", "Game Process Not Found", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						break;
					case DLLInjection.DllInjectionResult.InjectionFailed:
						MessageBox.Show("Injection failed!", "Injection Failed", MessageBoxButtons.OK, MessageBoxIcon.Hand);
						break;
				}
			}
		}

		public void LaunchExploit()
		{
			bool flag = REAS.namedPipeExist("EXPLOIT DLL PIPE NAME");
			bool flag2 = flag;
			bool flag3 = flag2;
			if (flag3)
			{
				MessageBox.Show("Already Attached!", "NamedPipeExist!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
			}
			else
			{
				bool flag4 = File.Exists("EXPLOIT DLL NAME.dll");
				bool flag5 = flag4;
				bool flag6 = flag5;
				if (flag6)
				{
					this.InjectDLL();
				}
				else
				{
					this.DownloadDLL();
					MessageBox.Show("Downloading DLL", "Roblox Exploit API Source");
					this.InjectDLL();
					MessageBox.Show("Finished downloading.. Injecting..", "Roblox Exploit API Source");
					MessageBox.Show("API Injected", "Roblox Exploit API Source");
				}
			}
		}

		private static bool namedPipeExist(string pipeName)
		{
			bool result;
			try
			{
				bool flag = !REAS.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\.\\pipe\\{0}", pipeName)), 0);
				bool flag2 = flag;
				bool flag3 = flag2;
				if (flag3)
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					bool flag4 = lastWin32Error == 0;
					bool flag5 = flag4;
					bool flag6 = flag5;
					if (flag6)
					{
						result = false;
						return result;
					}
					bool flag7 = lastWin32Error == 2;
					bool flag8 = flag7;
					bool flag9 = flag8;
					if (flag9)
					{
						result = false;
						return result;
					}
				}
				result = true;
			}
			catch (Exception)
			{
				result = false;
			}
			return result;
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern bool WaitNamedPipe(string name, int timeout);
		private WebClient wc = new WebClient();
	}
}
